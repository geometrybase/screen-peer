(function() {
  'use strict';

  angular.module('screenPeer', []);

})();

(function() {

  'use strict';

  angular
  .module('screenPeer')
  .factory('DataConnection',['EventEmitter','Negotiator','screenPeerUtil','$timeout','uuid','logging',fn]);

  function fn(EventEmitter,Negotiator,screenPeerUtil,$timeout,uuid,logging){

    var $log=logging('DataConnection');

    function DataConnection(peer,provider,options){

      EventEmitter.call(this);    
      this.options=screenPeerUtil.extend({
        serialization:'json',
        type:'sync',
        reliable:false
      },options);

      this._lostMessages=[],

      //connection is not open yet
      this.idPrefix='dc_';
      this.open=false;
      this.destroyed=false;
      this.type=this.options.type;
      this.peer=peer;
      if(!this.options._payload){
        this.originator=true;
      }else{
        this.originator=false; 
      }
      this.provider=provider;
      this.id=this.options.connectionId || this.idPrefix+screenPeerUtil.randomToken();
      this.label=this.options.label || this.id;
      this.metadata=this.options.metadata;
      this.serialization=this.options.serialization;
      this.reliable=this.options.reliable;
      this.timeouts={};
      this.callbacks={};

      //Data channel buffering
      this._buffer=[];
      this._buffering=false;
      this.bufferSize=0;

      //For storing large data.
      this._chunkedData={};

      if(this.options._payload){
        this._peerBrowser=this.options._payload.browser; 
      }

      Negotiator.startConnection(this,this.options._payload || {
        originator:true
      });
    }

    screenPeerUtil.inherits(DataConnection,EventEmitter);

    //Called by the negotiator when the DataChannel is ready
    DataConnection.prototype.initialize=function(dc){
      this._dc=this.dataChannel=dc; 
      this._configureDataChannel();
    };

    DataConnection.prototype._configureDataChannel=function(){
      $log.debug('Config data channel',this._dc);
      var self=this; 
      if(screenPeerUtil.supports.sctp){
        this._dc.binaryType='arraybuffer'; 
      }
      this._dc.onerror=function(err){
        $log.error('data channel error',err); 
      }
      this._dc.onopen=function(){
        $log.debug('Data chnnel connection success'); 
        self.open=true;
        self.sendLostMessage();
        self.emit('open');
      }
      this._dc.onmessage=function(e){
        self._handleDataMessage(e); 
      } 
      this._dc.onbufferedamountlow=function(){
        $log.warn('onbufferedamountlow'); 
      };
      this._dc.onclose=function(err){
        $log.debug('DataChannel closed for:',self.peer); 
        if(!self.destroyed && self.originator){
          Negotiator.startConnection(self,{originator:true}); 
        }
      }
    };

    DataConnection.prototype._handleDataMessage=function(e){
      var self=this; 
      var data=e.data;
      var datatype=data.constructor;
      if(this.serialization==='json'){
        if(angular.isString(data)){
          var t=Date.now();
          try{
            data=angular.fromJson(data);
          }catch(e){
          }
        }
      }
      if(data.__peerData){
        var id=data.__peerData; 
        var chunkInfo=this._chunkedData[id] || {
          data:[],
          count:0,
          timeStamp:Date.now(),
          total:data.total
        };
        chunkInfo.data[data.n]=data.data;
        chunkInfo.count+=1;
        if(chunkInfo.total === chunkInfo.count){
          delete this._chunkedData[id];
          if(this.serialization==='json'){
            data=chunkInfo.data.join(''); 
          }
          this._handleDataMessage({data:data});
        }else{
          this._chunkedData[id]=chunkInfo;
        }
        return;
      }

      if(data.type==='RESPONSE' && this.callbacks[data.id]){
        $timeout.cancel(this.timeouts[data.id]);
        this.callbacks[data.id](null,data.payload);
        delete this.callbacks[data.id];
      }else if(data.type==='DATA'){
        this.provider.emit('data',{peer:this.peer,payload:data.payload}); 
      }else if(data.type==='REQUEST'){
        this.provider.emit('action',{peer:this.peer,payload:data.payload,id:data.id}); 
      }
    };

    DataConnection.prototype.disconnect=function(){
      if(!this.open) 
        return;
      this.open=false;
      Negotiator.cleanup(this);
      this.emit('disconnect');
    };

    DataConnection.prototype.destroy=function(){
      this.destroyed=true; 
      this.removeAllListeners();
      this.disconnect();
    };

    DataConnection.prototype.sendRequest=function(data,timeout,callback){
      $log.debug('DataConnection.sendRequest(data,timeout,callback) called.');
      var self=this;
      var actionId=uuid.v4();
      this.send({type:'REQUEST',payload:data,id:actionId});
      this.callbacks[actionId]=callback;
      this.timeouts[actionId]=$timeout(function(){
        delete self.timeouts[actionId];
        delete self.callbacks[actionId];
        callback('No action response in '+timeout); 
      },timeout);
    };

    DataConnection.prototype.sendResponse=function(actionId,data){
      var self=this; 
      this.send({type:'RESPONSE',payload:data,id:actionId,peer:this.provider.id});
    };

    DataConnection.prototype.sendData=function(data){
      this.send({type:'DATA',payload:data}); 
    };

    DataConnection.prototype.sendLostMessage=function(){
      var self=this;
      this._lostMessages.forEach(function(m){
        self.send(m.data,m.chunked); 
      });
    };

    DataConnection.prototype.send=function(data,chunked){
      if(this.destroyed){
        return this.emit('error', new Error('Connection is destroyed.'));
      }
      if(!this.open){
        return this._lostMessages.push({data:data,chunked:chunked});
      }
      var self=this;
      if(this.serialization==='json'){
        if(!angular.isString(data))
          var t=Date.now();
          data=angular.toJson(data);
        var needsChunking=screenPeerUtil.chunkedBrowsers[this._peerBrowser] || screenPeerUtil.chunkedBrowsers[screenPeerUtil.brower];
        if(needsChunking && !chunked && data.length>screenPeerUtil.chunkedMTU){
          this._sendChunks(data); 
        }else{
          this._bufferedSend(data); 
        }
      }else{
        self._bufferedSend(ab); 
      }
    };

    DataConnection.prototype._bufferedSend=function(msg){
      if(this._buffering || !this._trySend(msg)){
        this._buffer.push(msg); 
        this.bufferSize=this._buffer.length;
      } 
    };

    DataConnection.prototype._trySend=function(msg){
      try{
        this._dc.send(msg); 
      }catch(e){
        $log.debug(e);
        this._buffering=true;  
        var self=this;
        $timeout(function(){
          self._buffering=false;
          self._tryBuffer();
        },10);
        return false;
      }    
    };

    DataConnection.prototype._tryBuffer=function(){
      if(this._buffer.length===0){
        return; 
      } 
      var msg=this._buffer[0];
      if(this._trySend(msg)){
        this._buffer.shift(); 
        this.bufferSize=this._buffer.length;
        this._tryBuffer();
      }
    };

    DataConnection.prototype._sendChunks=function(str){
      var self=this;
      var strs=screenPeerUtil.chunkString(str); 
      $log.debug('chunks length',strs.length);
      strs.forEach(function(s){
        self.send(s,true); 
      });
    };

    DataConnection.prototype.handleMessage=function(message){
      var payload=message.payload; 
      switch(message.type){
        case 'ANSWER':
          $log.debug('handle ANSWER for',message.src,'sdp',payload.sdp);
          this._peerBrowser=payload.browser;
          //Forward to negotiator
          Negotiator.handleSDP(message.type,this,payload.sdp);
          break; 
        case 'CANDIDATE':
          $log.debug('handle CANDIDATE for',message.src)
          Negotiator.handleCandidate(this,payload.candidate);
          break;
        default:
          $log.warn('Unrecogized message type:',message.type,'from peer:',this.peer);
      }
    };

    return DataConnection
  }

})();

(function() {

  'use strict';

  angular
  .module('screenPeer')
  .factory('RTCSessionDescription', RTCSessionDescription)
  .factory('RTCPeerConnection', RTCPeerConnection)
  .factory('RTCIceCandidate', RTCIceCandidate)
  .factory('io',io)
  .factory('_',lodash)
  .factory('EventEmitter',EventEmitter)
  .factory('d3',d3)
  .factory('uuid',uuid);


  function uuid($window){
    return $window.uuid; 
  }

  function d3($window){
    return $window.d3; 
  }

  function RTCSessionDescription($window){
    return $window.RTCSessionDescription || $window.mozRTCSessionDescription;
  }

  function RTCPeerConnection($window){
    return $window.RTCPeerConnection || $window.mozRTCPeerConnection || $window.                       webkitRTCPeerConnection;
  }

  function RTCIceCandidate($window){
    return $window.RTCIceCandidate || $window.mozRTCIceCandidate;
  }


  function io($window){
    return $window.io; 
  }

  function lodash($window){
    return $window._; 
  }

  function EventEmitter($window){
    return $window.EventEmitter; 
  }


})();

(function() {

  'use strict';

  angular
  .module('screenPeer')
  .provider('logging',function(){

    var self=this;
    this.logLevel='info'; 

    this.setLogLevel=function(logLevel){
      this.logLevel=logLevel; 
    };

    this.$get=['$log','d3',function($log,d3){

      var color=d3.scale.category20();
      function enhanceLogging(loggingFunc, context) {
        return function() {
          var modifiedArguments = [].slice.call(arguments);
          var moment=Date.now();
          if(context.length<20){
            context=' '.repeat(20-context.length)+context; 
          }else if(context.length>20){
            context='...'+context.substr(context.length-17,17); 
          }
          moment=moment.toString().substr(8);
          modifiedArguments.unshift('background: '+color(context)+'; color: white;font-size:12px;padding:0 10px;line-height:1.2;');
          modifiedArguments.unshift('%c' + context + '>');

          loggingFunc.apply(null, modifiedArguments);
        };
      }

      return function logger(context) {
        var level=0;
        switch(self.logLevel){
          case 'debug':
            level=0;
          break;
          case 'log':
            level=1;
          break;
          case 'info':
            level=2;
          break;
          case 'warn':
            level=3;
          break;
          default:
            level=4;
        }
        return {
          debug : level<=0?enhanceLogging($log.debug, context):function(){},
          log   : level<=1?enhanceLogging($log.log, context):function(){},
          info  : level<=2?enhanceLogging($log.info, context):function(){},
          warn  : level<=3?enhanceLogging($log.warn, context):function(){},
          error : level<=4?enhanceLogging($log.error, context):function(){}
        };
      };
    }];
  });

})();

(function() {

  'use strict';

  angular
  .module('screenPeer')
  .factory('Negotiator',['_','RTCPeerConnection','RTCSessionDescription','RTCIceCandidate','screenPeerUtil','logging',fn]);

  function fn(_,RTCPeerConnection,RTCSessionDescription,RTCIceCandidate,screenPeerUtil,logging){
    var $log=logging('Negotiator');
    var Negotiator={
      pcs:{
        data:{}, 
        media:{},
        sync:{}
      }, //type=>{peerId:{pc_id:pc}}.
      //providers:{},//provider's id=>providers(there may be multiple providers/client.
      queue:[]//connection thart are delayed due to a PC being in use.
    }
    Negotiator._idPrefix='pc_';
    /** Returns a PeerConnection object set up correctly(fro data,media). */
    Negotiator.startConnection=function(connection,options){
      //connection is an DataConnection or MediaConnection object 
      var pc=Negotiator._getPeerConnection(connection,options);
      //Set the conntion's PC.
      connection.pc=connection.peerConnection=pc;
      //What do we need to do now?
      if(options.originator){
        //Create the datachannel 
        var config={
          ordered: false
        };
        if(!screenPeerUtil.supports.sctp){
          config={reliable:options.reliable}; 
        }
        var dc=pc.createDataChannel(connection.label,config);
        connection.initialize(dc);
      }else{
        Negotiator.handleSDP('OFFER',connection,options.sdp); 
      }
    };

    Negotiator._getPeerConnection=function(connection,options){
      if(!Negotiator.pcs[connection.type]){
        $log.error(connection.type+' is not a valid connection type. Maybe you overrode the `type` property somewhere.') 
      } 
      if(!Negotiator.pcs[connection.type][connection.peer]){
        Negotiator.pcs[connection.type][connection.peer]={}; 
      }
      //var peerConnections=Negotiator.pcs[connection.type][connection.peer];
      var pc;
      if(options.pc){ //Simplest case: PC is already provided for us
        pc=Negotiator.pcs[connection.type][connection.peer][options.pc];
      }
      if(!pc || pc.signalingState !== 'stable'){
        pc=Negotiator._startPeerConnection(connection);
      }
      $log.debug(pc);
      return pc;
    };

    Negotiator._startPeerConnection=function(connection){
      $log.debug('Creating RTCPeerConnection'); 
      var id=Negotiator._idPrefix+screenPeerUtil.randomToken();
      var optional={};
      if(!screenPeerUtil.supports.sctp){
        optional={optional:[{RtpDataChannels:true}]}; 
      }  
      var pc=new RTCPeerConnection(connection.provider.options.config,optional);
      Negotiator.pcs[connection.type][connection.peer][id] = pc;
      Negotiator._setupListeners(connection,pc,id);
      return pc;
    }

    /** Set up various WebRTC listeners. */
    Negotiator._setupListeners=function(connection,pc,pc_id){
      var peer=connection.peer;
      var connectionId=connection.id;
      var provider=connection.provider;

      //ICE CANDIDATES
      $log.debug('Listening for ICE candidates');
      pc.onicecandidate=function(evt){
        if(evt.candidate){
          $log.debug('Receive ICE candidates for:',connection.peer); 
          $log.debug(evt.candidate);
          $log.debug('send to',peer);
          provider.socket.emit('message',{
            type:'CANDIDATE', 
            payload:{
              candidate:evt.candidate, 
              type:connection.type,
              connectionId:connection.id
            },
            dst:peer
          });
        } 
      };

      pc.oniceconnectionstatechange=function(){
        switch(pc.iceConnectionState){
          case 'failed': 
            $log.debug('iceConnectionState is disconnected, closing connections to '+peer);
            connection.emit('error',new Error('Negotiation of connection to '+peer+' failed.'));
            if(!connection.destroyed && connection.originator){
              Negotiator.startConnection(connection,{originator:true});
            }
            break;
          case 'disconnected':
            $log.debug('iceConnectionState is disconnected, closing connections to '+peer);
            if(!connection.destroyed && connection.originator){
              Negotiator.startConnection(connection,{originator:true});
            }
            break;
          case 'completed':
            $log.debug('oniceconnectionstatechange completed');
            pc.onicecandidate=screenPeerUtil.noop;
            break;
        } 
      };

      //Fallback for older Chrome impls.
      pc.onicechange=pc.oniceconnectionstatechange;

      //ONNEGOTIATIONNEEDED (Chrome)
      $log.debug('Listening for `negotiationneeded`');
      pc.onnegotiationneeded=function(){
        $log.debug('`negotiationneeded` triggered'); 
        if(pc.signalingState=='stable'){
          Negotiator._makeOffer(connection);
        }else{
          $log.debug('onnegotiationneeded triggered when not stable. Is another connection being established?'); 
        }
      };

      //dataconnection
      $log.debug('Listening for data channel');
      //Fired between offer and answer, so options should already be save in the options hash.
      pc.ondatachannel=function(evt){
        $log.debug('Receive data channel');
        var dc=evt.channel;
        var connection=provider.getConnection(peer,connectionId);
        connection.initialize(dc);
      };

      //mediaconnection
      //$log.debug('Listening for remote stream');
      //pc.onaddstream=function(evt){
        //$log.debug('Receive remote stream'); 
        //var stream=evt.stream;
        //var connection=provider.getConnection(peer,connectionId);
        //if(connection.type==='media'){
          //connection.addStream(stream);
        //}
      //};
    };

    Negotiator.cleanup=function(connection){
      $log.debug('Cleaning up PeerConnection to '+connection.peer); 
      var pc=connection.pc;
      if(!!pc && (pc.readyState !== 'closed' || pc.signalingState !== 'closed')){
        pc.close();
        connection.pc=null;
      }
    };

    Negotiator._makeOffer=function(connection){
      $log.debug('make offer for:',connection.peer);
      var pc=connection.pc; 
      pc.createOffer(function(offer){
        //if(!screenPeerUtil.supports.sctp && connection.reliable){
          //offer.sdp=Reliable.higherBandwidthSDP(offer.sdp);   
        //}
        pc.setLocalDescription(offer,function(){
          $log.debug('Set localDescription: offer','for:',connection.peer); 
          connection.provider.socket.emit('message',{
            type:'OFFER',
            payload:{
              sdp:offer, 
              type:connection.type,
              lable:connection.label,
              connectionId:connection.id,
              reliable:connection.reliable,
              serialization:connection.serialization,
              browser:screenPeerUtil.browser
            },
            dst:connection.peer
          });
        },function(err){
          connection.provider.emitError('webrtc',err); 
          $log.debug('Failed to setLocalDescription,',err);
        });
      },function(err){
        connection.provider.emitError('webrtc',err); 
        $log.debug('Failed to createOffer,',err);
      },connection.options.constraints);
    };

    Negotiator._makeAnswer=function(connection){
      var pc=connection.pc; 
      pc.createAnswer(function(answer){
       $log.debug('Created answer.');  
       //if(!screenPeerUtil.supports.sctp && connection.reliable){
          //answer.sdp=Reliable.higherBandwidthSDP(answer.sdp); 
       //}
       pc.setLocalDescription(answer,function(){
          connection.provider.socket.emit('message',{
            type:'ANSWER', 
            payload:{
              sdp:answer, 
              type:connection.type,
              connectionId:connection.id,
              browser:screenPeerUtil.browser
            },
            dst:connection.peer
          }); 
       },function(err){
          connection.provider.emitError('webrtc',err); 
          $log.debug('Failed to setLocalDescription');
       });
      },function(err){
        connection.provider.emitError('webrtc',err);
        $log.debug('Failed to create answer,',err);
      });
    };

    /** Handle an SDP. */
    Negotiator.handleSDP=function(type,connection,sdp){
      $log.debug('SDP',sdp);
      sdp=new RTCSessionDescription(sdp); 
      var pc=connection.pc;
      $log.debug('Setting remote description',sdp);
      pc.setRemoteDescription(sdp,function(){
        $log.debug('Set remoteDescription:',type,'for:',connection.peer);
        if(type==='OFFER'){
          Negotiator._makeAnswer(connection); 
        }
      },function(err){
        connection.provider.emitError('webrtc',err); 
        screenPeerUtil.log('Failed to setRemoteDescription,',err);
      });
    };

    /** Handle a candidate */
    Negotiator.handleCandidate=function(connection,ice){
      var candidate=ice.candidate; 
      var sdpMLineIndex=ice.sdpMLineIndex;
      connection.pc.addIceCandidate(new RTCIceCandidate({
        sdpMLineIndex:sdpMLineIndex,
        candidate:candidate
      }));
      $log.debug('Added ICE candidate for:',connection.peer);
    };

    return Negotiator;
  }

})();


(function() {

  'use strict';

  angular
  .module('screenPeer')
  .service('ScreenPeer',['_','io','Socket','EventEmitter','screenPeerUtil','DataConnection','$timeout','logging',fn]);

  function fn(_,io,Socket,EventEmitter,screenPeerUtil,DataConnection,$timeout,logging){

    var $log=logging('ScreenPeer');

    function ScreenPeer(options){
      $log.info(screenPeerUtil);

      if(!(this instanceof ScreenPeer)) return new ScreenPeer(options);

      EventEmitter.call(this);
      options=screenPeerUtil.extend({
        config:screenPeerUtil.defaultConfig
      },options);

      this.options=options;
      this.destroyed=false; //syncConnections have been killed
      this.disconnected=false; //connection to server killed but p2p syncConnections still active
      this.open=false; //sockets and such are not yet open.

      //references
      this.connections={
        all:{} 
      }

      this._lostMessages={}; //src=>[list of messages]
      this.master=false;


      if(!screenPeerUtil.supports.audioVideo && !screenPeerUtil.supports.data){
        this._delayedAbort('browser-incompatiable','The curent browser does not support WebRTC');
        return;
      }

      if(angular.isString(this.options.organization) && angular.isString(this.options.exhibition) && angular.isString(this.options.scene) && angular.isString(this.options.screen)){
        this._initializeServerConnection();
      }else{
        this._delayedAbort('invalid-options','organization or exhibiton or scene or screen name is not in options'); 
      }
    }

    screenPeerUtil.inherits(ScreenPeer,EventEmitter);

    ScreenPeer.prototype.syncData=function(data){
      for(var peer in this.connections['sync']){
        var connection=this.connections['sync'][peer];  
        connection.sendData(data);
      }
    };

    ScreenPeer.prototype.syncRequest=function(data,timeout,callback){
      for(var peer in this.connections['sync']){
        var connection=this.connections['sync'][peer];  
        connection.sendRequest(data,timeout,callback);
      }
    };

    ScreenPeer.prototype.sendResponse=function(peer,actionId,data){
      var connection=this.connections['all'][peer];
      connection.sendResponse(actionId,data);
    };

    ScreenPeer.prototype.sendData=function(peerId,data){
      var connection=this.syncConnections[peerId];
      if(connection){
        connection.sendData(data);
      }else{
        $log.error('DataConneciton to',peerId,'is not exist!'); 
      }
    };

    ScreenPeer.prototype.sendRequest=function(peerId,data,timeout,callback){
      var connection=this.connections['all'][peerId];
      if(connection){
        connection.sendRequest(data,timeout,callback);
      }else{
        $log.error('DataConneciton to',peerId,'is not exist!'); 
      }
    };

    //Initialize the socket
    ScreenPeer.prototype._initializeServerConnection=function(){
      $log.debug('Initialize server connection.');
      var self=this; 
      this.socket=Socket(this.options.secure,this.options.host,this.options.port);
      this.socket.on('connect',function(){
        self.id=self.socket.id;
        $log.debug('Catch socket `connect` event, emit screen options.',self.options);
        self.socket.emit('options',{
          organization:self.options.organization,
          exhibition:self.options.exhibition,
          scene:self.options.scene,
          screen:self.options.screen
        });
      });
      this.socket.on('message',function(data){
        self._handleMessage(data); 
      });
      this.socket.on('error',function(error){
        self._abort('socket-error',error); 
      });
      this.socket.on('disconnect',function(){
        $log.debug('Catch socket `disconnect` event');
        self.emitError('network','Lost connection to server.'); 
        if(!self.disconnected){
          self.disconnect();
        } 
      });
      this.socket.on('close',function(){
        $log.debug('Catch socket `close` event');
        if(!self.disconnected){
          self._abort('socket-closed','Underlying socket is already closed');
        } 
      });
    };

    ScreenPeer.prototype._updatePeers=function(peers){
      var self=this;
      var peersInScene=[]; 
      peers.map(function(peer){
        if(peer._id===self.id){
          self.peerInScene=peer; 
        }
        if(peer.scene===self.options.scene){
          peersInScene.push(peer);
        }
      });
      this.peersInScene=peersInScene;
      if(!this.master && peersInScene[0]._id===this.id){
        this.master=true;
        this.emit('master',true);
      }else if(this.master && peersInScene[0]._id!==this.id){
        this.master=false;
        for(var key in this.connections['all']){
          var connection=this.connections['all'][key]; 
          if(connection.originator){
            connection.destroy(); 
          } 
        }
        this.emit('master',false);
      };
      if(this.master){
        this._tryConnectPeersInScene(); 
      }
    };


    ScreenPeer.prototype._tryConnectPeersInScene=function(){
      var self=this;
      this.peersInScene.forEach(function(peer){
        if(peer._id !== self.id && !self.connections['all'][peer._id]){
          self.connect(peer._id,{type:'sync'}); 
        } 
      }); 
    }

    ScreenPeer.prototype._handleMessage=function(message){
      var type=message.type; 
      var payload=message.payload;
      var peer=message.src;
      var connection;
      switch(type){
        case 'PEERS':
          $log.debug('Receive message: PEERS in exhibition.',message.payload);
        this._updatePeers(message.payload);
        this.emit('open',this.id);
        this.open=true;
        break;
        case 'ERROR':
          $log.error('Recive message: ERROR,',payload.msg);
        this._abort('server-error',payload.msg);
        break;
        case 'SCREEN-TAKEN':
          $log.error('Recive message: SCREEN-TAKEN');
        this._abort('screen-exists','SCREEN "'+this.options.organization+'/'+this.options.exhibition+'/'+this.options.scene+'/'+this.options.screen+'" is exists');
        break;
        case 'INVALID-KEY':
          this._abort('invalid-key','API KEY "'+this.options.key+'" is invalid')
        break;
        case 'LEAVE':
          $log.debug('Receive leave message from ',peer,message);
        this._cleanupPeer(peer);
        break;
        case 'EXPIRE'://The offer sent to a peer has expired without response.
          this.emitError('peer-unavailable','Could not connect to peer '+peer);
        break;
        case 'OFFER':
          var connectionId=payload.connectionId;
        $log.debug('Receive message: OFFER from',peer);
        connection=this.getConnection(peer,connectionId);
        if(connection){
          $log.warn('Offer received for existing Connection ID:',connectionId); 
        }else{
          connection=new DataConnection(peer,this,{
            connectionId:connectionId, 
            _payload:payload,
            metadata:payload.metadata,
            type:payload.type,
            label:payload.label,
            serialization:payload.serialization,
            reliable:payload.reliable
          });  
          this._addConnection(peer,connection);
          this.emit('connection',connection);
        }
        var messages=this._getMessages(connectionId);
        messages.forEach(function(message){
          connection.handleMessage(message); 
        });
        break;
        default:
          if(!payload){
          $log.debug('You receive a malformed message from '+peer+' of type '+type);
          return;
        }
        $log.debug('Receive message:',type);
        connection=this.getConnection(peer);
        if(connection && connection.pc){
          connection.handleMessage(message);
        }else if(payload.connectionId){
          this._storeMessage(payload.connectionId,message); 
        }else{
          $log.warn('You receive an unrecognized message:',message); 
        }
      }
    };

    ScreenPeer.prototype._storeMessage=function(connectionId,message){
      if(!this._lostMessages[connectionId]){
        this._lostMessages[connectionId]=[]; 
      } 
      this._lostMessages[connectionId].push(message);
    };

    ScreenPeer.prototype._getMessages=function(connectionId){
      var messages=this._lostMessages[connectionId]; 
      if(messages){
        delete this._lostMessages[connectionId];
        return messages;
      }else{
        return []; 
      }
    };

    ScreenPeer.prototype.connect=function(peer,options){
      if(this.disconnected){
        $log.warn('You cannot connect to a new Peer because you called .disconnect() on this peer.You can create a new peer to reconnect, or call reconnect on this peer if you believe its ID still be available'); 
        return;
      } 
      var connection=new DataConnection(peer,this,options);
      this._addConnection(peer,connection);
      return connection;
    };

    ScreenPeer.prototype._addConnection=function(peer,connection){
      if(!this.connections[connection.type]){
        this.connections[connection.type]={};
      }
      this.connections['all'][peer]=connection;
      this.connections[connection.type][peer]=connection;
    };

    ScreenPeer.prototype.getConnection=function(peer){
      return this.connections['all'][peer];
    };


    ScreenPeer.prototype.emitError=function(type,err){
      $log.error('Error:',err);
      if(typeof err==='string'){
        err=new Error(err); 
      }
      err.type=type;
      this.emit('error',err);
    };

    ScreenPeer.prototype.destroy=function(){
      if(!this.destroyed){
        this.socket.close();
        this._cleanup(); 
        this.removeAllListeners();
        this.destroyed=true;
        this.disconnected=true;
        this.open=false;
      } 
    };

    ScreenPeer.prototype._delayedAbort=function(type,message){
      var self=this; 
      $timeout(function(){
        self._abort(type,message); 
      });
    };

    ScreenPeer.prototype._abort=function(type,message){
      this.disconnect(); 
      this.emitError(type,message);
    };

    ScreenPeer.prototype._cleanup=function(){
      for(var key in this.connections['all']){
        var connection=this.connections['all'][key];
        if(connection){
          delete this.connections['all'][key];
          delete this.connections[connection.type][key];
          connection.destroy();
        }
      }
      this._lostMessages={};
    };

    ScreenPeer.prototype.disconnect=function(){
      $log.debug('Disconnect socket connection and close all data connection.')
      var self=this; 
      $timeout(function(){
        if(!self.disconnected){
          self.disconnected=true; 
          self.open=false;
          if(self.socket && self.socket.connected){
            $log.debug('Disconnect socket',self.socket);
            self.socket.disconnect(); 
          }
          self._cleanup();
          self.emit('disconnected',self.id);
          self.id=null;
        }
      });
    };

    ScreenPeer.prototype.reconnect=function(){
      if(this.disconnected && !this.destroyed){
        $log.debug('Attempting reconnection to server with ID',this._lastServerId); 
        this.socket.connect(); 
      }else if(this.destroyed){
        throw new Error('This peer cannot reconnect to the server. It has already been destroyed.'); 
      }else if(!this.disconnected && !this.open){
        //Do nothing. We're still connection the first time.
        $log.error('In a hurry?We\'re still trying to make initial connection!');  
      }else{
        throw new Error('Peer '+this.id+' cannot reconnect because it is not disconnected from ther server'); 
      } 
    }

    ScreenPeer.prototype._cleanupPeer = function(peer) {
      var connection=this.connections['all'][peer];
      if(connection){
        delete this.connections['all'][peer];
        delete this.connections[connection.type][peer];
        connection.destroy();
      }else{
        $log.warn('peer not exist',this.connections); 
      }
    };

    return ScreenPeer
  }

})();

(function() {

  'use strict';

  angular
  .module('screenPeer')
  .factory('Socket', ['io',fn]);

  function fn(io){
    return  function Socket(secure,host,port){
      var wsProtocol=secure?'wss://':'ws://'; 
      var wsUrl=wsProtocol+host+':'+port;
      return io(wsUrl)
    }
  }

})();

(function() {

  'use strict';

  angular
  .module('screenPeer')
  .service('screenPeerUtil',['RTCPeerConnection','$window','$timeout',screenPeerUtil]);

  function screenPeerUtil(RTCPeerConnection,$window,$timeout){

    var self=this;

    this.defaultConfig={
      'iceServers':[{
        'url':'stun:stun.l.google.com:19302'
      }] 
    }; 
    this.dataCount = 1;
    this.noop = function(){};

    //Browsers that need chunking;
    this.chunkedBrowsers = {'Chrome':1};
    this.chunkedMTU = 16300; //The original 60000 bytes setting does not work when sending data from Firefox to Chrome, which is "cut off" after 16384 bytes and delivered individually
    this.browser = (function(){
      if($window.mozRTCPeerConnection){
        return 'Firefox'; 
      }else if($window.webkitRTCPeerConnection){
        return 'Chrome'; 
      }else if($window.RTCPeerConnection){
        return 'Supported'; 
      }else{
        return 'Unsupported'; 
      } 
    })();

    this.supports = (function(){
      if(typeof RTCPeerConnection === 'undefined'){
        return {};
      }
      var data=true;
      var audioVideo=true;
      var binaryBlob=false;
      var sctp=false;
      var onnegotiationneeded = !!$window.webkitRTCPeerConnection;
      var pc,dc;
      try{
        pc = new RTCPeerConnection(self.defaultConfig, {
          optional:[{RtpDataChannels: true}]
        });
      }catch(e){
        data=false; 
        audioVideo=false;
      }

      if(data){
        try{
          dc=pc.createDataChannel('_PEERJSTEST'); 
        }catch(e){
          data=false; 
        }
      }

      if(data){
        //Binary test 
        try{
          dc.binaryType='blob'; 
          binaryBlob=true;
        }catch(e){

        }

        //Reliable test.
        //Unfortunately Chrome is a bit unreliable about whether or not they support reliable.
        var reliablePC=new RTCPeerConnection(self.defaultConfig,{});
        try{
          var reliableDC=reliablePC.createDataChannel('_PEERJSRELIABLETEST',{}); 
          sctp=reliableDC.reliable;
        }catch(e){

        }
        reliablePC.close();
      }

      //FIXME: not really the best check...
      if(audioVideo){
        audioVideo=!!pc.addStream; 
      }

      //FIXME: this is not great because in theory it doesn't work for av-only browsers(?)
      if(!onnegotiationneeded && data){
        //sync default check.
        var negotiationPC=new RTCPeerConnection(self.defaultConfig,{optional:[{RtpDataChannels:true}]});
        negotiationPC.onnegotiationneeded=function(){
          onnegotiationneeded=true; 
          //async check.
          if(peerUtil && peerUtil.supports){
            peerUtil.supports.onnegotiationneeded=true; 
          }
        }
        negotiationPC.createDataChannel('_PEERJSNEGOTIATIONTEST');

        $timeout(function(){
          negotiationPC.close(); 
        },1000)
      }
      if(pc){
        pc.close(); 
      }

      return {
        audioVideo:audioVideo, 
        data:data,
        binaryBlob:binaryBlob,
        sctp:sctp,
        onnegotiationneeded:onnegotiationneeded
      }

    })();

    //Ensure alphanumeric ids
    this.validateId = function(id){
      // Allow empty ids
      return !id || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(id);
    };

    this.inherits = function(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }; 

    this.extend = function(dest, source) {
      for(var key in source) {
        if(source.hasOwnProperty(key)) {
          dest[key] = source[key];
        }
      }
      return dest;
    }; 

    this.chunkString = function(str){
      var chunks=[]; 
      var size=str.length;
      var start=0;
      var index=0;
      var total=Math.ceil(size/peerUtil.chunkedMTU);
      while(start<size){
        var end=Math.min(size,start+peerUtil.chunkedMTU); 
        var b=str.slice(start,end);
        var chunk={
          __peerData:this.dataCount,
          n:index,
          data:b,
          total:total
        };
        chunks.push(chunk);
        start=end;
        index+=1;
      }
      this.dataCount+=1;
      return chunks;
    };

    //Binary stuff
    //chunks a blob
    this.chunk = function(bl){
      var chunks=[]; 
      var size=bl.size;
      var start=0;
      var index=0;
      var total=Math.ceil(size/peerUtil.chunkedMTU);
      while(start<size){
        var end=Math.min(size,start+peerUtil.chunkedMTU); 
        var b=bl.slice(start,end);
        var chunk={
          __peerData:dataCount,
          n:index,
          data:b,
          total:total
        };
        chunks.push(chunk);
        start=end;
        index+=1;
      }
      dataCount+=1;
      return chunks;
    };

    this.blobToArrayBuffer = function(blob,cb){
      var fr=new $window.FileReader(); 
      fr.onload=function(evt){
        cb(evt.target.result); 
      }
      fr.readAsBinaryString(blob);
    };

    this.binaryStringToArrayBuffer = function(binary){
      var byteArray=new Uint8Array(binary.length); 
      for(var i=0; i<binary.length; i++){
        byteArray[i]=binary.charCodeAt(i) & 0xff;
      }
      return byteArray.buffer;
    };

    this.randomToken = function(){
      return Math.random().toString(36).substr(2); 
    };

    this.isSecure = function(){
      return $window.location.protocol==='https'; 
    };

  }
})();
